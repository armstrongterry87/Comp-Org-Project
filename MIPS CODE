.data
prompt_msg: .asciiz "Enter an integer N (N >= 22): "
error_msg:  .asciiz "Illegal Number! N must be >= 22.\n"
newline:    .asciiz "\n"
comma_space: .asciiz ", "

.text
.globl main

main:
    #Step 1: Input and Validation Loop
input_loop:
    # Step 2: prompt the user for N

    li $v0, 4            # Load syscall code for print_string
    syscall              # REad integer into $v0
    move $s0, $v0        # Move N from $v0 to $s0 (N is stored in $s0)

    #3. check for legality(N < 22)
    li    $t1, 22
    blt    $s0, $t1, illegal_input    #Branch if N < 22

    #Input is legal go to step 2
    j    fibonacci_sequence

illegal_input:
    #display error message
    li    $v0, 4            # Load syscall code for print string
    la    $a0, error_msg    #Load address of error message
    syscall                 # print error_msg

    #loop back to get new input
    j    input_loop         # go back to input_loop


    #Step 2: Fibonacci Sequence Calculation and Printing
fibonacci_sequence:
    # Initialize registers for Fibonacci
    # $s0 holds N (the count limit)
    # $s1 holds F_prev (starts at 0, F_0)
    # $s2 holds F_curr (starts at 1, F_1)
    # $t0 holds loop counter i (starts at 0)

    li   $s1, 0                 # F_prev = 0 (F_0)
    li   $s2, 1                 # F_curr = 1 (F_1)
    li   $t0, 0                 # i = 0 (counter)

    #check if N is 0 since N >= 22

print_loop:
    #check if we printed N numbers (i < N)
    bge    $t0, $s0, end_program # if i >= N, sequence is complete

    # check if i > 0 to deicing on printing ","
    bne    $t0, 0, print_coma    #If i != 0, print deperator

print_number:
    # Determine the number to print:
    # If i = 0, print $s1 (0)
    # If i = 1, print $s2 (1)
    # If i >= 2, print $s2 (F_curr) which has the next value

    li    $v0, 1                # load syscall code for print_int
    bgt    $t0, 0, print_fcurr  #if i > 0, we print F_curr($s2)

    # case i = 0: print F_0 ($s1)
    move $a0, $s1               #load 0 into $a0
    syscall                     # print 0
    j    update_fib_and_counter #done printing for i=0
print_fcurr:
    #case i >= 1: print_fcurr
    move $a0, $s2               #load F_curr into $a0
    syscall                     #print F_curr
    #the first 2 nums are 0 and 1 and are printed outside the calculation
    #so calculation needs to wait until i >= 2

update_fib_and_counter:
    #calculation only happens starting from the end of the i = 1 loop iteration
    #for the next number (i=2)
    addi $t0, $t0, 1            #increment counter i



